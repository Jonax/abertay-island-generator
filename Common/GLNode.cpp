//////////////////////////////////////////////////////////////////////////////////////////
//						  Dynamic Terrain Generation Prototype							//
//					  Written 2007 by Jon Wills (jc@chromaticaura.net)						//
//				Written for a Win32 environment using the DirectSound API.				//
//																						//
//				   Written at the University of Abertay Dundee, Scotland				//
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//	NODE CLASS CODE																		//
//	Used as a means to hold position & texture coordinate data for an OpenGL vertex.	//
//	Used as a base class for the terrain & the skydome.									//
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//	CLASS HEADER
//////////////////////////////////////////////////////////////////////////////////////////
#include "GLNode.h"

//	Generic constructor.  Creates a node at (0, 0, 0).
//////////////////////////////////////////////////////////////////////////////////////////
GLNode::GLNode()
{
	this->Position	= GLVertex();
	this->Texture	= GLVertex2();
}

//	Constructor.  Creates a node at (x, y, z).
//////////////////////////////////////////////////////////////////////////////////////////
GLNode::GLNode(GLfloat x, GLfloat y, GLfloat z)
{
	this->Position	= GLVertex(x, y, z);
	this->Texture	= GLVertex2();
}

//	Function to set the node's position.  
//////////////////////////////////////////////////////////////////////////////////////////
void GLNode::Set(GLfloat x, GLfloat y, GLfloat z)
{
	this->Position = GLVertex(x, y, z);
}

//	Function to set the node's texture coordinates.  
//////////////////////////////////////////////////////////////////////////////////////////
void GLNode::SetTex(GLfloat x, GLfloat z)
{
	this->Texture.x = x;
	this->Texture.y = z;
}

// Function to return the node's cross product.  
//////////////////////////////////////////////////////////////////////////////////////////
void GLNode::Draw()
{
	glVertex3f(Position.x,	Position.y,	Position.z);
}

// Function to return the node's length.  
//////////////////////////////////////////////////////////////////////////////////////////
float GLNode::Length()
{
	return (sqrt(	(Position.x * Position.x)
				 +	(Position.y * Position.y)
				 +	(Position.z * Position.z)));
}

// Function to normalise the node.  
//////////////////////////////////////////////////////////////////////////////////////////
void GLNode::Normalise()
{
	this->Position /= this->Length();
}

// Operator to subtract the node to another vertex.
//////////////////////////////////////////////////////////////////////////////////////////
GLNode GLNode::operator - (GLNode &rhs)
{
	return GLNode(	Position.x - rhs.Position.x, 
					Position.y - rhs.Position.y, 
					Position.z - rhs.Position.z);
}

// Function to return the node's cross product.  
//////////////////////////////////////////////////////////////////////////////////////////
GLNode GLNode::Cross(GLNode& rhs)
{
	return GLNode(	(Position.y * rhs.Position.z) - (Position.z * rhs.Position.y),
					(Position.z * rhs.Position.x) - (Position.x * rhs.Position.z), 
					(Position.x * rhs.Position.y) - (Position.y * rhs.Position.x));
}